<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Wasm vs JS: The Scaling Benchmark</title>
    <style>
        body { font-family: system-ui, sans-serif; padding: 20px; max-width: 900px; margin: 0 auto; }
        h1 { margin-bottom: 5px; }
        .subtitle { color: #666; margin-bottom: 25px; font-size: 1.1rem; }

        table { border-collapse: collapse; width: 100%; margin-top: 20px; font-size: 0.9rem; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        th, td { border: 1px solid #ddd; padding: 10px; text-align: right; }
        th { background-color: #f8f9fa; text-align: center; font-weight: 600; }
        tr:nth-child(even) { background-color: #fcfcfc; }

        .header-col { text-align: left; font-weight: bold; background: #f8f9fa; }

        /* Status Colors */
        .slower { color: #d9534f; font-weight: bold; } /* Red */
        .faster { color: #28a745; font-weight: bold; } /* Green */
        .equal  { color: #999; font-style: italic; }    /* Grey */

        button {
            padding: 12px 24px;
            font-size: 1rem;
            cursor: pointer;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            transition: background 0.2s;
        }
        button:hover { background: #0056b3; }
        button:disabled { background: #ccc; cursor: not-allowed; }
    </style>
</head>
<body>
    <h1>Wasm vs JS Interaction Benchmark</h1>

    <p class="subtitle">
        Isolating the raw Wasm-to-JS boundary cost ("Trampolining") and comparing it against the heavy cost of DOM updates.
    </p>

    <button id="runBtn" onclick="runSuite()">Run Full Benchmark Suite</button>
    <span id="status" style="margin-left: 15px; font-weight: 500; color: #007bff;"></span>

    <table id="resultsTable">
        <thead>
            <tr>
                <th rowspan="2" style="width: 15%;">Iterations</th>
                <th colspan="3" style="background: #e3f2fd;">Experiment A: Boundary Overhead<br><small>(Empty Call - Pure Trampoline Cost)</small></th>
                <th colspan="3" style="background: #fff3e0;">Experiment B: Real Workload<br><small>(DOM Update - Heavy Payload)</small></th>
            </tr>
            <tr>
                <th style="background: #e3f2fd;">JS Direct</th>
                <th style="background: #e3f2fd;">Wasm -> JS</th>
                <th style="background: #e3f2fd;">Factor</th>

                <th style="background: #fff3e0;">JS Direct</th>
                <th style="background: #fff3e0;">Wasm -> JS</th>
                <th style="background: #fff3e0;">Factor</th>
            </tr>
        </thead>
        <tbody>
            </tbody>
    </table>

    <div style="margin-top: 20px; padding: 10px; border: 1px solid #eee; background: #f9f9f9;">
        <strong>Live DOM Target:</strong> <span id="target" style="color: green; font-weight: bold;">0</span>
        <ul id="targetList">
          <li></li>
        </ul>
    </div>


    <script>
        // --- Configuration ---
        const POWERS = [10, 100, 1000, 10000, 100000, 1000000, 10000000];
        const targetDiv = document.getElementById('target');
        const targetList = document.getElementById('targetList');
        const tableBody = document.querySelector('#resultsTable tbody');
        const statusSpan = document.getElementById('status');

        // The Empty Function (for pure overhead measurement)
        const js_empty = (i) => { return; };

        // The DOM Function (for real world simulation)
        const js_dom = (i) => {
          if (i % 10000 == 0) {
            targetList.innerHTML = "";
          }
          const li = document.createElement('li');
          li.textContent = `Item ${i}`;
          targetList.appendChild(li);
        };

        async function runSuite() {
            document.getElementById('runBtn').disabled = true;
            tableBody.innerHTML = ""; // Clear previous results

            statusSpan.innerText = "Loading WebAssembly...";
            const importObject = {
                env: {
                    js_empty: js_empty,
                    js_dom: js_dom
                }
            };

            const wasmStream = await WebAssembly.instantiateStreaming(
                fetch('experiment.wasm'), importObject
            );
            const exports = wasmStream.instance.exports;

            for (let iterations of POWERS) {
                statusSpan.innerText = `Running ${iterations.toLocaleString()} iterations...`;

                // Allow the browser to update the table
                await new Promise(r => requestAnimationFrame(() => setTimeout(r, 50)));

                const row = document.createElement('tr');
                row.innerHTML = `<td class="header-col">${iterations.toLocaleString()}</td>`;

                // EXPERIMENT A: pure overhead measurement

                // JS Direct
                targetList.innerHTML = "";
                let start = performance.now();
                for(let i=0; i<iterations; i++) js_empty(i);
                let jsTimeA = performance.now() - start;

                // Wasm -> JS
                targetList.innerHTML = "";
                start = performance.now();
                exports.bench_empty(iterations);
                let wasmTimeA = performance.now() - start;

                appendResultCells(row, jsTimeA, wasmTimeA);

                // EXPERIMENT B: DOM Updates

                // JS Direct
                targetList.innerHTML = "";
                start = performance.now();
                for(let i=0; i<iterations; i++) js_dom(i);
                let jsTimeB = performance.now() - start;

                // 2. Wasm -> JS
                targetList.innerHTML = "";
                start = performance.now();
                exports.bench_dom(iterations);
                let wasmTimeB = performance.now() - start;

                appendResultCells(row, jsTimeB, wasmTimeB);

                tableBody.appendChild(row);
            }

            statusSpan.innerText = "Done!";
            document.getElementById('runBtn').disabled = false;
        }

        function appendResultCells(row, jsTime, wasmTime) {
            // Prevent division by zero for very fast runs
            jsTime = Math.max(jsTime, 0.01);
            wasmTime = Math.max(wasmTime, 0.01);

            const ratio = wasmTime / jsTime;
            let factorText = "";
            let cssClass = "equal";

            // We use a 5% threshold to decide if it's actually different
            if (ratio > 1.05) {
                factorText = `${ratio.toFixed(1)}x Slower`;
                cssClass = "slower";
            } else if (ratio < 0.95) {
                factorText = `${(1/ratio).toFixed(1)}x Faster`;
                cssClass = "faster";
            } else {
                factorText = "Equal";
            }

            row.innerHTML += `
                <td>${jsTime.toFixed(2)} ms</td>
                <td>${wasmTime.toFixed(2)} ms</td>
                <td class="${cssClass}">${factorText}</td>
            `;
        }
    </script>
</body>
</html>
